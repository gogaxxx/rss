#!/usr/bin/perl

use strict;
use cfg;

use Encode;
use File::Copy;
use POSIX qw(strftime);
use RSS::Item;
use RSS::Transform;

my @to_process = @ARGV;

for my $pindex (@to_process) {
	my $p = $cfg::to_process{$pindex};

    unless (defined($p)) {
        die("No configuration for '$pindex' in cfg\n");
    }

    $p->{'sorting'}  ||= $cfg::sorting;
    $p->{'maxitems'} ||= $cfg::maxitems;

	open (ORDER, '<'.$p->{'input'});
	my @order = ();
	while (my $line1 = <ORDER>) {

		chomp $line1;
		my @fields = split(/\s+/o, $line1);

		push @order, [ @fields ];
	}
	close(ORDER);

	@order = sort { $a->[0] <=> $b->[0] } @order;

	my $part = 0;
	my $item = 0;
	my @piece_of_lenta = ();

	my $l = scalar(@order);

	my $style_links =
		[
			'<link rel="stylesheet" type="text/css" href="'.$p->{style}.'">'
		];

	for (my $i = 0; $i < $l; $i++) {
	#    print (":", $f->[1], " - ", $part, "\n");
		my $f = $order[$i];

		# TODO проверка ошибок при загрузке (eval)
		my $item_data = RSS::Item::load_item($f->[1]);
		RSS::Transform::transform_item($item_data);
		my $html = item_to_html($item_data);
		my $chunk = Encode::encode('utf-8', $html);

		if ($p->{'sorting'} eq 'new_first') {
			unshift @piece_of_lenta, $chunk;
		}
		elsif ($p->{'sorting'} eq 'old_first') {
			push @piece_of_lenta, $chunk;
		}
		$item ++;

		if ($item >= $p->{'maxitems'}) {
			$part ++;

			my $prev_links = prev_part($p, $part);
			my $next_links = ($i < $l-1 
						 		? next_part($p, $part) 
								: ['','']);
            open(OUTPUT, '>'.sprintf($p->{'output_tmp'}, $part));
			print OUTPUT '<html>';
			print OUTPUT header($prev_links, $next_links, $style_links);
			print OUTPUT @piece_of_lenta;
			print OUTPUT $prev_links->[1],
                         '&nbsp;&nbsp;',
						 $next_links->[1];
			print OUTPUT '</html>';
			close OUTPUT;

			$item=0;
			@piece_of_lenta = ();
		}
	}
	if ($item > 0) {
        $part ++;
		my $prev_links = prev_part($p, $part);
        open(OUTPUT, '>'.sprintf($p->{'output_tmp'}, $part));
		print OUTPUT header($prev_links, $style_links);
		print OUTPUT @piece_of_lenta;
		print OUTPUT $prev_links->[1];
        close OUTPUT;
	}

    my $filename = 
        $p->{'sorting'} eq 'new_first'
            ? sprintf($p->{'output_tmp'}, $part)
            : 
        $p->{'sorting'} eq 'old_first'
            ? sprintf($p->{'output_tmp'}, 1)
            : '';

	copy($filename, $p->{'output_start'});
}

sub prev_part {
	my $p = shift;
	my $part = shift;

	if ($part > 1) {
		my $href = sprintf($p->{'output_tmp'}, $part-1);
		return 
			[
				q{<link rel="prev" href="}.$href.'">',
				q{<a href="}.$href.q{">&lt;&lt;Older</a>}
			]
	}
	else {
		return [ '', ''];
	}
}

sub next_part {
	my $p = shift;
	my $part = shift;

	my $href = sprintf($p->{'output_tmp'}, $part+1);
	return
		[
			q{<link rel="next" href="}.$href.'">',
	 		q{<a href="}.$href.q{">Newer&gt;&gt;</a>}
		];
}

sub header {
	return ('<head>', 
			(map { $_->[0]} @_),
			'</head>');
}

sub item_to_html {
	my $item = shift;

	my $html = '';
    my $show_link = substr($item->{link}, 0, 40);
    if (length($show_link) < length($item->{link})) {
            $show_link .= '...';
    }
	# TODO: move to templates
	my $link_html = 
		'<a class="itemlink" href="'
		. $item->{link}
		. '" target=_blank>[link-='.$item->{name}.': '
		. $show_link. ']</a>';
    $html .= join('', '<h1>', $item->{subject},
                '</h1>', $link_html,
   				'<span class="date">',
                Encode::decode('utf-8', 
						strftime($cfg::date_format, 
							localtime($item->{'time'}))),
                '</span><div class="body">',
    			$item->{body}, '</div>', $link_html, '<br clear=all><hr>');

    return $html;
}
