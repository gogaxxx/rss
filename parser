#!/usr/bin/perl
#
# Copyright (c) 2005 George 'Nephrite' Potapov <nephrite@inbox.ru>
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# $Id: rss2mail 10 2008-01-08 22:34:16Z nephrite $
#

use strict;

use lib '.';
use cfg;

use utf8;

use Date::Parse;
use Encode;
use Fcntl qw(:DEFAULT :flock :seek);
use AnyDBM_File;
use POSIX qw(strftime);

use XML::Parser;

my @where = (
	$cfg::items_dir.'/order',
	$cfg::items_dir.'/new'
);

MAIN: {
    $| = 1;

    check_and_create_db();

    my %guids;
    tie %guids, 'AnyDBM_File', $cfg::guiddatabase, O_CREAT|O_RDWR, 0666;

    my $parser = XML::Parser->new();

    for my $file (@ARGV) {
        print "\n", $file, ' ';

        $parser->setHandlers(Start => \&xml_start_detect);
		$parser->{guids} = \%guids;
		eval {
     	   $parser->parsefile($file);
		};
		if ($@) {
			warn "ERROR parsing $file: $@";
		}
    }

    untie %guids;
}

#+++1 Handlers
#+++2 xml_start_detect
sub xml_start_detect {
    my ($expat, $elem)=@_;

    if ($elem eq 'feed') {
        $expat->{type} = 'atom';
        print 'atom ';

        $expat->setHandlers(Start => \&atom_start,
                            End   => \&atom_end,
                            Char  => \&common_char);
    }
    elsif ($elem eq 'rss'
            || lc($elem) eq 'rdf:rdf')
    {
        $expat->{type} = 'rss';
        print 'rss ';
        $expat->setHandlers(Start => \&rss_start,
                            End   => \&rss_end,
                            Char  => \&common_char);
    }
    else {
        print 'UNKNOWN TYPE ';
        $expat->finish();
    }
}

#+++2 atom_start
sub atom_start {
    my ($expat, $elem, %attr)=@_;

    if ($elem eq 'entry') {
        $expat->{item} = {};
    }
    elsif ($elem eq 'link') {
        if ($attr{rel} eq 'alternate' 
            || !defined $expat->{item}{link}) 
        {
            $expat->{item}{link} = $attr{href};
        }
    }
    elsif ($elem eq 'id'
            || $elem eq 'title'
            || $elem eq 'published'
            || $elem eq 'updated'
			|| $elem eq 'created'
			|| $elem eq 'modified'
			|| $elem eq 'issued'
            || $elem eq 'content'
            || $elem eq 'summary')
    {
        $expat->{curparam} = $elem;
        $expat->{item}{$expat->{curparam}} = '';
    }
}

#+++2 atom_end 
sub atom_end {
    my ($expat, $elem)=@_;

    if ($elem eq 'entry') {
        my $item = $expat->{item};
        my $guid = $item->{id} || $item->{link};
            $guid =~ s/\s/_/go;
        save_item($expat->{guids}, {
                        subject => $item->{title},
                        date    => $item->{created}
									|| $item->{modified} 
									|| $item->{updated} 
                                    || $item->{published}
									|| $item->{issued},
                        body    => $item->{content}
                                    || $item->{summary},
                        guid    => $guid,
                        link    => $item->{link}
                    });
    }
    elsif ($elem eq 'id'
            || $elem eq 'title'
            || $elem eq 'published'
            || $elem eq 'updated'
			|| $elem eq 'created'
			|| $elem eq 'modified'
			|| $elem eq 'issued'
            || $elem eq 'content'
            || $elem eq 'summary') 
    {
        if($expat->{curparam} ne $elem) {
            $expat->finish();
        }
        else {
            $expat->{curparam} = undef;
        }
    }
}

#+++2 common_char
sub common_char {
    my ($expat, $string)=@_;

    if (defined $expat->{curparam}) {
        $expat->{item}{$expat->{curparam}} .= $string;
    }
}

#+++2 rss_start
sub rss_start {
    my ($expat, $elem, %attr)=@_;

    if ($elem eq 'item') {
        $expat->{item} = {};
    }
    elsif ($elem eq 'guid'
            || $elem eq 'title'
            || $elem eq 'pubDate'
            || $elem eq 'date'
            || $elem eq 'dc:date'
            || $elem eq 'description'
            || $elem eq 'content:encoded'
			|| $elem eq 'link')
    {
        $expat->{curparam} = $elem;
        $expat->{item}{$expat->{curparam}} = '';
    }
}

#+++2 rss_end 
sub rss_end {
    my ($expat, $elem)=@_;

    if ($elem eq 'item') {
        my $item = $expat->{item};
        my $guid = $item->{guid} || $item->{link};
            $guid =~ s/\s/_/go;
        save_item( $expat->{guids}, {
                        subject => $item->{title},
                        date    => $item->{pubDate} 
									|| $item->{'dc:date'}, 
                        body    => $item->{'content:encoded'} 
									|| $item->{description},
                        guid    => $guid,
                        link    => $item->{link} || $guid
                    });
    }
    elsif ($elem eq 'guid'
            || $elem eq 'title'
            || $elem eq 'pubDate'
            || $elem eq 'date'
            || $elem eq 'dc:date'
            || $elem eq 'description'
            || $elem eq 'content:encoded'
			|| $elem eq 'link')
    {
        if($expat->{curparam} ne $elem) {
            $expat->finish();
        }
        else {
            $expat->{curparam} = undef;
        }
    }
}

### save_item ####+++1
sub save_item {
    my ($guids, $item)=@_;

	return if ($guids->{$item->{guid}});

	$guids->{$item->{guid}} = 1;

    $item->{'time'} = 
		$item->{date}
			?  str2time($item->{date})
			:  time();

    Encode::_utf8_off($item->{subject});
    Encode::_utf8_off($item->{body});

	transform_item($item);

    $item->{'name'} = get_saved_id();

    open (OUT, '>' . $cfg::items_dir . '/'. $item->{'name'});
    my $show_link = substr($item->{link}, 0, 40);
    if (length($show_link) < length($item->{link})) {
            $show_link .= '...';
    }
    print OUT ('<h1>', $item->{subject},
                '</h1><a class="itemlink" href="', 
                $item->{link},
                '" target=_blank>[link-='.$item->{name}.': ', $show_link, ']</a>');
    print OUT ('<span class="date">',
                strftime($cfg::date_format, localtime($item->{'time'})),
                '</span><div class="body">');
    print OUT ($item->{body}, '</div><br clear=all><hr>');
    close OUT;

	save_item_data($item);

    save_id($item->{'name'});
    print($item->{'name'}, ' ');
}

### transform_item  ####### #+++2
#
# transform item to something better
#
# TODO сделать plugin'ы для трансформации, а то эта функция грозит
# разрастись
#
sub transform_item {
	my $item = shift;
	if ($item->{link} =~ /theregister\.com/o) {
		# делать линк на печатную версию вместо обычной
		$item->{link} .= '/print.html';
	}
	elsif ($item->{link} =~ /lj\.rossia\.org/o) {
		# ljro shit # XXX dirty hack
		$item->{body} =~ s/<\/?font[^>]*>//g;
	}
	elsif ($item->{link} =~ /idiottoys\.com/o) {
		transform_idiot($item);
	}
} #---2

# transform_idiot #+++2
sub transform_idiot {
	my $item=shift;

	use HTML::Parser;
	my $parser = HTML::Parser->new(
		xml_mode => 1,
		case_sensitive => 0,
		start_h => [ \&idiot_start,   'self,tagname, attr, text'],
		default_h => [ \&idiot_default, 'self,text' ]
	);

	$parser->{OUTPUT} = '';
	$parser->parse($item->{body});

	$item->{body} = $parser->{OUTPUT};
}

### idiot_start  ####### #+++3
sub idiot_start {
	my ($self, $tagname, $attr, $text)=@_;

	my $t1;
	if ($tagname eq 'img') {
		$t1 = idiot_tr_link('img', 'src', $attr);
	}
	elsif ($tagname eq 'a') {
		$t1 = idiot_tr_link('a', 'href', $attr);
	}
	$text = 
		$t1 ? $t1 : $text;
	idiot_default($self, $text);
}
### idiot_tr_link  ####### #+++3
sub idiot_tr_link {
	my ($tagname, $href_name, $attr)=@_;

	if ($attr->{$href_name} !~ m{^http://}o) {
		$attr->{$href_name} =
			'http://www.idiottoys.com'.$attr->{$href_name};
		return join(' ', '<'.$tagname,
						(map {
							$_.'="'.$attr->{$_}.'"'
						} keys %$attr)). '>';
	}
	return undef;
}
### idiot_default  ####### #+++3
sub idiot_default {
	my ($self, $text)=@_;

	$self->{OUTPUT} .= $text;
}
#---2

sub get_saved_id {
    if (open(IN, '<'.$cfg::items_dir.'/number')) {
        my $id = <IN>;
        close IN;

        while (-e $cfg::items_dir.'/'.$id) {
            $id++;
        }
        return $id || 0; 
    }
    else {
        return 0;
    }
}

sub save_id {
    my $id = shift;

    if (open(OUT, '>'.$cfg::items_dir.'/number')) {
        print OUT $id;
        close OUT;
    }
}

# check_and_create_db #+++1
#
# проверить, существует ли guids.db и собрать его из мастер файла
#
sub check_and_create_db {
    my $need_remake = 0;
	#my $db_filename = $cfg::guiddatabase.'.db';
    my $db_filename = $cfg::guiddatabase;

	my $guidmaster = $cfg::items_dir.'/order';

    if (-e $guidmaster 
            and
        !-e $db_filename) 
    {
        # отсутствует db файл - просто пересобрать из мастера
        $need_remake = 1;
    }
    elsif (!-e $guidmaster) {
        # отсутствует мастер - db недействителен!
        # создаём пустой мастер и пустой db
        open(MASTER, '>'.$guidmaster);
        close MASTER;
        unlink($db_filename);
        $need_remake = 1;
    }
    elsif (-e $guidmaster 
            and
           -e $db_filename)
    {
        # оба файла существуют - хорошо!
        # проверим, если мастер обновлён позже db - пересобрать
        my @master_stat = stat($guidmaster);
        my @db_stat     = stat($db_filename);

        if ($master_stat[9] > $db_stat[9]) {
            $need_remake = 1;
        }
    }

    if ($need_remake) {
        warn "Rebuilding database...\n";
        my %guids;
        tie %guids, 'AnyDBM_File', $cfg::guiddatabase, O_CREAT|O_RDWR, 0666;

        if (open(MASTER, '<'.$guidmaster)) {
            while (my $line = <MASTER>) {
                chomp $line;
				my @parts = split(/\s+/o, $line);
                $guids{$parts[2]} = 1;
            }
            close FILE;
        }

        untie %guids;
    }
}

### save_item_data ####### #+++1
#
# write one item data to index file
#
sub save_item_data {
	my $item=shift;

	for my $f (@where) {
		open (OUT, '>>'.$f);
        flock(OUT, LOCK_EX) or die("Can't flock: $!");
        seek(OUT, 0, SEEK_END) or die("Can't seek: $!");
        print OUT $item->{'time'}, ' ', 
                  $item->{'name'}, ' ',
                  $item->{'guid'}, "\n";
        flock(OUT, LOCK_UN) or die("Can't unlock: $!");
		close(OUT);
	}
}
