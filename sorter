#!/usr/bin/perl

use strict;
use lib '.';
use cfg;

use Encode;
use File::Copy;
use POSIX qw(strftime);
use RSS::Item;

my @to_process = @ARGV;

for my $pindex (@to_process) {
	my $p = $cfg::to_process{$pindex};

    unless (defined($p)) {
        die("No configuration for '$pindex' in cfg\n");
    }

    $p->{'sorting'}  ||= $cfg::sorting;
    $p->{'maxitems'} ||= $cfg::maxitems;

	open (ORDER, '<'.$p->{'input'});
	my @order = ();
	while (my $line1 = <ORDER>) {

		chomp $line1;
		my @fields = split(/\s+/o, $line1);

		push @order, [ @fields ];
	}
	close(ORDER);

	@order = sort { $a->[0] <=> $b->[0] } @order;

	my $part = 0;
	my $item = 0;
	my @piece_of_lenta = ();

	my $l = scalar(@order);

	my $style_links =
		[
			'<link rel="stylesheet" type="text/css" href="'.$p->{style}.'">'
		];

	for (my $i = 0; $i < $l; $i++) {
	#    print (":", $f->[1], " - ", $part, "\n");
		my $f = $order[$i];

		# TODO проверка ошибок при загрузке (eval)
		my $item_data = RSS::Item::load_item($f->[1]);
		transform_item($item_data);
		my $html = item_to_html($item_data);
		my $chunk = Encode::encode('utf-8', $html);

		if ($p->{'sorting'} eq 'new_first') {
			unshift @piece_of_lenta, $chunk;
		}
		elsif ($p->{'sorting'} eq 'old_first') {
			push @piece_of_lenta, $chunk;
		}
		$item ++;

		if ($item >= $p->{'maxitems'}) {
			$part ++;

			my $prev_links = prev_part($p, $part);
			my $next_links = ($i < $l-1 
						 		? next_part($p, $part) 
								: ['','']);
            open(OUTPUT, '>'.sprintf($p->{'output_tmp'}, $part));
			print OUTPUT '<html>';
			print OUTPUT header($prev_links, $next_links, $style_links);
			print OUTPUT @piece_of_lenta;
			print OUTPUT $prev_links->[1],
                         '&nbsp;&nbsp;',
						 $next_links->[1];
			print OUTPUT '</html>';
			close OUTPUT;

			$item=0;
			@piece_of_lenta = ();
		}
	}
	if ($item > 0) {
        $part ++;
		my $prev_links = prev_part($p, $part);
        open(OUTPUT, '>'.sprintf($p->{'output_tmp'}, $part));
		print OUTPUT header($prev_links, $style_links);
		print OUTPUT @piece_of_lenta;
		print OUTPUT $prev_links->[1];
        close OUTPUT;
	}

    my $filename = 
        $p->{'sorting'} eq 'new_first'
            ? sprintf($p->{'output_tmp'}, $part)
            : 
        $p->{'sorting'} eq 'old_first'
            ? sprintf($p->{'output_tmp'}, 1)
            : '';

	copy($filename, $p->{'output_start'});
}

sub prev_part {
	my $p = shift;
	my $part = shift;

	if ($part > 1) {
		my $href = sprintf($p->{'output_tmp'}, $part-1);
		return 
			[
				q{<link rel="prev" href="}.$href.'">',
				q{<a href="}.$href.q{">&lt;&lt;Older</a>}
			]
	}
	else {
		return [ '', ''];
	}
}

sub next_part {
	my $p = shift;
	my $part = shift;

	my $href = sprintf($p->{'output_tmp'}, $part+1);
	return
		[
			q{<link rel="next" href="}.$href.'">',
	 		q{<a href="}.$href.q{">Newer&gt;&gt;</a>}
		];
}

sub header {
	return ('<head>', 
			(map { $_->[0]} @_),
			'</head>');
}

### transform_item  ####### #+++1
#
# transform item to something better
#
# TODO сделать plugin'ы для трансформации, а то эта функция грозит
# разрастись
#
sub transform_item {
	my $item = shift;
	# для всех: сцылки на youtube прописываем явно в тексте
	my @videos = ();
	while ($item->{body} =~ m{<[^>]+\=['"]?(http://(?:[^\.]+\.)?youtube\.com/[^'"\s>]+)}sg) { 
		push @videos, $1;
	}
	$item->{body} .= '<br>'.join('<br>', map { 'Video: '.$_} @videos);

	if ($item->{link} =~ /theregister\.com/o) {
		# делать линк на печатную версию вместо обычной
		$item->{link} .= '/print.html';
	}
	elsif ($item->{link} =~ /lj\.rossia\.org/o) {
		# ljro shit # XXX dirty hack
		$item->{body} =~ s/<\/?font[^>]*>//g;
	}
	elsif ($item->{link} =~ /idiottoys\.com/o) {
		transform_idiot($item);
	}
} #---2

# transform_idiot #+++2
sub transform_idiot {
	my $item=shift;

	use HTML::Parser;
	my $parser = HTML::Parser->new(
		xml_mode => 1,
		case_sensitive => 0,
		start_h => [ \&idiot_start,   'self,tagname, attr, text'],
		default_h => [ \&idiot_default, 'self,text' ]
	);

	$parser->{OUTPUT} = '';
	$parser->parse($item->{body});

	$item->{body} = $parser->{OUTPUT};
}

### idiot_start  ####### #+++3
sub idiot_start {
	my ($self, $tagname, $attr, $text)=@_;

	my $t1;
	if ($tagname eq 'img') {
		$t1 = idiot_tr_link('img', 'src', $attr);
	}
	elsif ($tagname eq 'a') {
		$t1 = idiot_tr_link('a', 'href', $attr);
	}
	$text = 
		$t1 ? $t1 : $text;
	idiot_default($self, $text);
}
### idiot_tr_link  ####### #+++3
sub idiot_tr_link {
	my ($tagname, $href_name, $attr)=@_;

	if ($attr->{$href_name} !~ m{^http://}o) {
		$attr->{$href_name} =
			'http://www.idiottoys.com'.$attr->{$href_name};
		return join(' ', '<'.$tagname,
						(map {
							$_.'="'.$attr->{$_}.'"'
						} keys %$attr)). '>';
	}
	return undef;
}
### idiot_default  ####### #+++3
sub idiot_default {
	my ($self, $text)=@_;

	$self->{OUTPUT} .= $text;
}
#---2

sub item_to_html {
	my $item = shift;

	my $html = '';
    my $show_link = substr($item->{link}, 0, 40);
    if (length($show_link) < length($item->{link})) {
            $show_link .= '...';
    }
	# TODO: move to templates
	my $link_html = 
		'<a class="itemlink" href="'
		. $item->{link}
		. '" target=_blank>[link-='.$item->{name}.': '
		. $show_link. ']</a>';
    $html .= join('', '<h1>', $item->{subject},
                '</h1>', $link_html,
   				'<span class="date">',
                Encode::decode('utf-8', 
						strftime($cfg::date_format, 
							localtime($item->{'time'}))),
                '</span><div class="body">',
    			$item->{body}, '</div>', $link_html, '<br clear=all><hr>');

    return $html;
}
